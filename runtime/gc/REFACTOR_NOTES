=============================================================================
STATUS
=============================================================================

Next todo:
  - Intermediate goal, remove pre-allocated levels for hierarchical heap.
    1. rename HM_chunkList->parent to representative
    2. hijack HM_chunkList objects as heap objects
        - reuse representative pointers
        - give HM_chunkList a nextNonEmptyAncestor pointer
          (ancestor in the heap hierarchy!)

Done:
  - thread->level, instead of hh->...
  - renamed thread->level to thread->currentDepth
  - thread->{bytesAllocated..., bytesSurvived...}, instead of hh->...
  - move hh->lastAllocatedChunk to thread->lastAllocatedChunk
  - renamed lastAllocatedChunk to currentChunk

=============================================================================
GOAL
=============================================================================

The goal is to recreate the level-linked data structure for hierarchical heaps,
with various improvements along the way. Heaps will be organized into a
tree where intermediate empty levels are skipped. We will also link heaps into
a dynamic disjoint-set data structure instead of their constituent chunklist
objects.
  - unbounded fork depth
  - no cost (space or time!!) for unused empty levels
  - single-point-of-allocation for runtime metadata (the heap objects)

The data structure will look roughly like this:

  struct GC_heap {
    /* in the path-compressing query tree */
    struct GC_heap* representative;

    /* in the heap hierarchy. not necessarily immediate parent, as some levels
     * can be empty.*/
    struct GC_heap* nextAncestor;

    chunklist smallObjectsSpace;
    chunklist largeObjectsSpace;
    chunklist rememberedSet;

    int depth;
  }

  struct GC_thread {
    ...
    struct GC_heap* heap;
    int currentDepth;
  }

